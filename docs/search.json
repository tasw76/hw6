[
  {
    "objectID": "hw6.html",
    "href": "hw6.html",
    "title": "hw6",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function\n\nlapply() is ued to apply a function over a list or vector and return a list. It is useful when we need to iterate over each element in a vector. The equivalent is map(). It also applies a function to each element of a vector and returns a list.\n\nUse lapply() to run the code cor(numeric_matrix, method = “kendall”) on my_list\n\n\n# This applies the cor() function to each element x in the list\noutput &lt;- lapply(my_list, function(x) cor(x, method = \"kendall\"))\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\nUsing purrr functions will return the output according to specific needs so that it ensures the results consistency. Base R usually returns a list, so it is not as flexible.\nPurrr package makes debugging easier, while Base R will stop running and return an error when the code has small errors.\n\nWhat is a side-effect function\n\nIt is a function with the purpose of producing some side effects other than returning a value. Print() is an example\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\nR has scoping rules that prevent such confusion.\n\n\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "hw6.html#task-1-conceptual-questions",
    "href": "hw6.html#task-1-conceptual-questions",
    "title": "hw6",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function\n\nlapply() is ued to apply a function over a list or vector and return a list. It is useful when we need to iterate over each element in a vector. The equivalent is map(). It also applies a function to each element of a vector and returns a list.\n\nUse lapply() to run the code cor(numeric_matrix, method = “kendall”) on my_list\n\n\n# This applies the cor() function to each element x in the list\noutput &lt;- lapply(my_list, function(x) cor(x, method = \"kendall\"))\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\nUsing purrr functions will return the output according to specific needs so that it ensures the results consistency. Base R usually returns a list, so it is not as flexible.\nPurrr package makes debugging easier, while Base R will stop running and return an error when the code has small errors.\n\nWhat is a side-effect function\n\nIt is a function with the purpose of producing some side effects other than returning a value. Print() is an example\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\nR has scoping rules that prevent such confusion.\n\n\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "hw6.html#task-2-writing-r-functions",
    "href": "hw6.html#task-2-writing-r-functions",
    "title": "hw6",
    "section": "Task 2 Writing R Functions",
    "text": "Task 2 Writing R Functions\n\n# Write a function called getRMSE() that takes in a vector of responses and a vector of predictions and outputs the RMSE\ngetRMSE &lt;- function(y, y_hat) {\n  squared_diff &lt;- (y - y_hat)^2\n  mean_squared_diff &lt;- mean(squared_diff)\n  rmse &lt;- sqrt(mean_squared_diff)\n  return(rmse)\n} \ny &lt;- c(3,-.5, 2, 7)\ny_hat &lt;- c(2.5,0,2,8)\ngetRMSE(y,y_hat)\n\n[1] 0.6123724\n\n\n\n# Modify the above basic function to allow missing values for the vector of responses\ngetRMSEv2 &lt;- function(y, y_hat, ...) {\n  squared_diff &lt;- (y - y_hat)^2\n  mean_squared_diff &lt;- mean(squared_diff, ...)\n  rmse &lt;- sqrt(mean_squared_diff)\n  return(rmse)\n} \ny &lt;- c(3, -0.5, NA, 7)\ny_hat &lt;- c(2.5, 0.0, 2, 8)\ngetRMSEv2(y, y_hat, na.rm = TRUE)\n\n[1] 0.7071068\n\n\n\n# Run the following code to create some response values and predictions, and test RMSE function\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\ngetRMSEv2(y, y_hat, na.rm = TRUE)\n\n[1] 0.7071068\n\nrmse_result &lt;- getRMSE(resp, pred)\nprint(rmse_result)\n\n[1] 0.9581677\n\n\n\n# Repeat after replacing two responses with missing values\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\nresp[1] &lt;- NA_real_\nresp[5] &lt;- NA_real_\n# Test RMSE function without specifying how to deal with missing values\nrmse_without_na_rm &lt;- getRMSE(resp, pred)\nprint(rmse_without_na_rm)\n\n[1] NA\n\n\n\n# Test RMSE function with specifying how to deal with missing values\nrmse_with_na_rm &lt;- getRMSEv2(resp, pred, na.rm = TRUE)\nprint(rmse_with_na_rm)\n\n[1] 0.9646971\n\n\n\n# Write another function getMAE()\ngetMAE &lt;- function(y, y_hat, ...) {\n  absolute_diff &lt;- abs(y - y_hat)\n  mae &lt;- mean(absolute_diff, ...)\n  return(mae)\n}\nact &lt;- c(3, -0.5, 2, 7)\npred &lt;- c(2.5, 0.0, 2, 8)\n# call the function\nmae_result &lt;- getMAE(act, pred)\nprint(mae_result)\n\n[1] 0.5\n\n\n\n# Run the following code to generate some response values and predictions, and then call the function getMAE\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nmae_result &lt;- getMAE(resp, pred)\nprint(mae_result)\n\n[1] 0.8155776\n\n\n\n# Repeat the above step after replacing two responses with missing values\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\nresp[1] &lt;- NA_real_\nresp[5] &lt;- NA_real_\nmae_without_na_rm &lt;- getMAE(resp, pred)\nprint(mae_without_na_rm)\n\n[1] NA\n\n\n\n# call the function with specifying the behavior to deal with missing values\nmae_with_na_rm &lt;- getMAE(resp, pred, na.rm = TRUE)\nprint(mae_with_na_rm)\n\n[1] 0.8210863\n\n\n\n# Wrapper function to calculate either or both metrics\ngetMetrics &lt;- function(y, y_hat, return_rmse = TRUE, return_mae = TRUE, ...) {\n  # Check if both arguments are atomic numeric vectors\n  if (!is.vector(y) || !is.atomic(y) || !is.numeric(y) || \n      !is.vector(y_hat) || !is.atomic(y_hat) || !is.numeric(y_hat)) {\n    message(\"Both y and y_hat must be numeric vectors.\")\n    return(NULL)\n  }\n\n  result &lt;- list()\n  \n  # Calculate and return RMSE\n  if (return_rmse) {\n    result$RMSE &lt;- getRMSE(y, y_hat, ...)\n  }\n  \n  # Calculate and return MAE \n  if (return_mae) {\n    result$MAE &lt;- getMAE(y, y_hat, ...)\n  }\n  \n  # Return the result list with appropriate names\n  return(result)\n}\n# Call function\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nmetrics_result &lt;- getMetrics(resp, pred)\nprint(metrics_result)\n\n$RMSE\n[1] 0.9581677\n\n$MAE\n[1] 0.8155776\n\n\n\n# Call the above function asking for each metric individually\nrmse_result_only &lt;- getMetrics(resp, pred, return_rmse = TRUE, return_mae = FALSE)\nprint(rmse_result_only)\n\n$RMSE\n[1] 0.9581677\n\n\n\n# Repeat with replacing the response values with missing values\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nresp[1] &lt;- NA_real_\nresp[5] &lt;- NA_real_\nmetrics_without_na_rm &lt;- getMetrics(resp, pred)\nprint(metrics_without_na_rm)\n\n$RMSE\n[1] NA\n\n$MAE\n[1] NA"
  },
  {
    "objectID": "hw6.html#task-3-querying-an-api-and-a-tidy-style-function",
    "href": "hw6.html#task-3-querying-an-api-and-a-tidy-style-function",
    "title": "hw6",
    "section": "Task 3 Querying an API and a Tidy-Style function",
    "text": "Task 3 Querying an API and a Tidy-Style function\n\ninstall.packages(\"httr\")\ninstall.packages(\"jsonlite\")\ninstall.packages(\"purrr\")\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(purrr)\n\napi_key &lt;- \"9d5a6f5abd414395a27a00a16cdec53a\"\n\nresponse &lt;-  GET(\"https://newsapi.org/v2/everything?q=gamestop&from=2024-10-01&language=en&pageSize=100&apiKey=9d5a6f5abd414395a27a00a16cdec53a\")\n\nnews_data &lt;- content(response, as = \"text\", encoding = \"UTF-8\")\nnews_json &lt;- fromJSON(news_data)\narticles &lt;- pluck(news_json, \"articles\")\narticle_list &lt;- as.list(articles)\n\nclass(article_list[[1]])  # This should return \"list\"\n\n\n# Write a quick function that allows the users to query this API. \nquery_news_api &lt;- function(query, from_date, api_key) {\n  \n  url &lt;- paste0(\"https://newsapi.org/v2/everything?q=\", query,\"&from=\", from_date, \n                &language=en&pageSize=100&apiKey=, api_key)\n  response &lt;- GET(url)\n\n  news_data &lt;- content(response, as = \"text\", encoding = \"UTF-8\")\n  \n  news_json &lt;- fromJSON(news_data)\n  \n  articles &lt;- pluck(news_json, \"articles\")\n  \n  }\n\n\n# 4. summarize the 'name' of the source for each article. (one way contingency table)\nsource_names &lt;- sapply(result_df$source, function(x) x$name)\nsource_table &lt;- table(source_names)\nprint(source_table)\n\n\n# 5. Turn the publishedAt column into a data column using 'lubridate package. \n\ninstall.packages(\"lubridate\")\ninstall.packages(\"dplyr\")\nlibrary(lubridate)\nlibrary(dplyr)\n\nresult_df &lt;- result_df %&gt;%\n  mutate(publishedAt = ymd_hms(publishedAt))\nsorted_df &lt;- result_df %&gt;%\n  arrange(publishedAt)\nsorted_df &lt;- sorted_df %&gt;%\n  mutate(pub_diff = publishedAt - lag(publishedAt))\nnew_result_df &lt;- sorted_df"
  }
]